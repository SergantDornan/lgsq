# Условие
	- Ограничение времени: 1с
	  Ограничение реального времени: 5 с
	  Ограничение памяти: 64 М
	- Реализуйте на языке ассемблера приведённую ниже функцию f.
	- ```
	  struct seq {
	  	signed char c;
	      short s;
	      struct seq *next;
	  }
	  
	  int f (struct seq *q) {
	  	if (!q)
	      	return 42;
	      return (f(q->next) % 2) ? q->s : q->c;
	  }
	  ```
	- Функция должна удовлетворять соглашению cdecl и правилам компиляции платформы IA-32/Linux.
	- Необходимо, чтобы ваш модуль мог быть скомпонован с модулем, содержащим вызывающую функцию, в среде Linux. Подсказка: используйте имя функции f (без подчеркивания) и не забудьте объявить её как глобальный символ с помощью директивы global.
- # Решение
	- По правилам выравнивания полей в структурах, поле размера N байт располагается по смещению, кратному N, начиная от адреса структуры.
	- Поэтому для структуры лежащей по адресу q её поле c будет лежать по адресу q, поле s будет лежать по адресу q + 2, а поле next лежать по адресу q + 4.
	- ```
	  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
	  | с |   |   s   |      next     |
	  ```
- # Ответ
	- ```
	  global f
	  f:
	  	push	ebp						; Сохранить указатель на предыдущий фрейм
	      mov		ebp, esp    			; Поместить в EBP адрес текущего фрейма
	      
	      push	ebx						; Сохранить EBX
	      
	      mov		eax, 42					; Положить 42 в EAX 
	      cmp		dword [ebp + 8], 0		; Сравнить значение q с 0
	      je		.end					; Если 0, вернуть 42
	      
	      mov		eax, dword [ebp + 8] 	; Положить в EAX значение адреса q
	      mov		eax, dword [eax + 4] 	; Положить в EAX значение поля q->next
	      								
	      	; ===== Состояние стека перед call f =====
	      	; 	16 байтная граница -> 	| q 				| +8
	      	;							| адрес возврата 	| +4
	      	;	ebp указывает сюда ->	| сохраненный ebp	| +0
	      	;							| сохраненный ebx	| -4
	      	; 	16 байтная граница -> 	| q->next			| -8
	        
	      push	eax						; Положить на стек первый аргумент функции f
	      call	f						; f(q->next)
	      add		esp, 4					; Удалить со стека аргумент функции
	      
	      								; В EAX лежит результат функции f(q->next)
	     
	     	xor		edx, edx				; Занулить EDX, подгатавливая к делению
	     	mov		ecx, 2					; Поместить 2 в ECX (делитель)
	      div		ecx						; Поделить EAX на 2 с остатком. Целая часть в EAX, остаток в EDX
	      
	      mov		ecx, dword [ebp + 8]	; Поместить в ECX значение указателя q
	      movsx	eax, byte [ecx]			; Поместить в EAX q->c cо знаковым дополнением char до int
	      cmp		edx, 0					; Сравнить EDX с 0
	      je		.end					; Если 0, вернуть q->c
	      movsx	eax, word [ecx + 2]		; Поместить в EAX q->s со знаковым дополнением short до int 
	      
	      .end:
	      pop		ebx						; Восстановить сохраненный EBX
	      
	      mov		esp, ebp				; Вернуть указатель стека на начало текущего фрейма
	      pop		ebp						; Положить в EBP сохранённый указатель на начало предыдущего фрейма
	      ret								; Вернуться из функции
	  ```