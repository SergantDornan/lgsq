- ```c++
  #include <regex>
  ```
- # Regexes
  collapsed:: true
	- ```c++
	  std::regex <regex_name>(<regex>); // объявление regex
	  ```
	  Обычно в конструктор можно засовывать string, но можно также и множество string подряд типа 
	  ```c++
	  std::regex reg("aboba" "22" "abcd");
	  ```
	  Тогда все они просто сложаться и запись будет эквивалентна
	  ```c++
	  std::regex reg("aboba22abcd");
	  ```
	- [<symbols>] - искать символы из списка symbols
	  
	  То есть выражение
	  ```c++
	  	std::regex reg("ape[abc]");
	  ```
	  Будет искать подстроки, которые начинаются с ape, а затем идет один символ, который является или a или b или с.
	  
	  Также можно указывать промежутки [C-Fc-f] - искать все символы с заглавной C по заглавную F и также все символы с маленькой c по маленькую f.
	  
	  **Также все специальные символы типа ) (  .  и тд надо указывать в [] если хотим их искать**
	- [^ <symbols>] - избегать символов из списка <symbols>
	  То есть выражение
	  ```c++
	  	std::regex reg("ape[^ abc]");
	  ```
	  Найдет все подстроки, которые начинаются с ape, после чего следует один символ, который не является пробелом, a,b или c.
	  
	  Аналогично можно указывать промежутки
	- +  означает любую последовательность символов (есть хотя бы один), ставится после особых выражений
	  То есть
	  ```c++
	  	std::regex reg("ape[^ abc]+");
	  ```
	  Эквивалентно записи 
	  ```c++
	  	std::regex reg("ape([^ abc]+)");
	  ```
	  Запись означает, что после ape следует последовательность из любого количества символов (хотя бы одного), которые не являются пробелом a, b или с.
	- ? - модификатор к особым выражениям, означает что символов может быть и нулевое количество.
	  
	  То есть выражение
	  ```c++
	  	std::regex reg("ape[^ abc]?");
	  ```
	  Найдет как подстроки, которые начинаются с ape, и у которых следующий символ либо отсутствует (то есть просто ape), либо присутствует и он не является пробелом, a, b или с.
	  
	  Выражение
	  ```c++
	  	std::regex reg("ape([^ abc]+)?");
	  ```
	  Найдет как подстроки, которые начинаются с ape, и у которых следующий символ либо отсутствует (то есть просто ape), либо присутствует множество символов и они все не являются пробелом, a, b или с.
	- () - скобочки, обозначают отдельную область видимости, интуитивно
	  
	  То есть в примере выражение
	  ```c++
	  	std::regex reg("ape([^ ]+)?");
	  ```
	  Выдаст на примере
	  
	  ```c++
	  std::string str = "The ape apex apeaboba";
	  ```
	  следующий результат
	  ```bash
	  ape 
	  apex
	  apeaboba
	  ```
	  Если не поставить скобочки, то неизвестно что произойдет
	- \\d - эквивалентно [0-9]
	  \\D - экиввалентно [^ 0-9]
	  \\w - экв [a-zA-z0-9]
	  \\W - экв [^ a-zA-z0-9]
	  . - точка, обозначает любой символ кроме пробелов
	- ```c++
	  	std::regex reg("\\d{5,7}");
	  ```
	  Все числа, в которых от 5 до 7 знаков, работает только с перечислением символов типа 
	  [abc1-4]{3}, работает с точкой, \\w и тд
	  **!!!!!! если дать этому регексу на вход 1234567890, то он не проигнорирует это число, а выведет 1234567**
	  
	  Вместо {} можно использовать * - это любое количество символов
	-
- # Возврат списка подстрок с помощью итератора
  collapsed:: true
	- ```c++
	  std::vector<std::string> find(std::string str, std::regex reg){
	  	std::sregex_iterator it(str.begin(), str.end(), reg);
	  	std::sregex_iterator lst;
	  	std::vector<std::string> res;
	  	while(it != lst){
	  		std::smatch match = *it;
	  		res.push_back(match.str());
	  		it++;
	  	}
	  	return res;
	  }
	  ```
- # Разные функции
  collapsed:: true
	- ## std::regex_replace
	  collapsed:: true
		- ```c++
		  std::string str = "Cat fat rat";
		  std::regex reg([ft]at);
		  std::string newstr = std::regex_replace(str,reg,"aboba");
		  std::cout << newstr;
		  ```
		  std::regex_replace создает новую строку, в которой заменяет все подстроки, удовлетворяющие регулярному выражению на какую то строку, которую мы указали в аргументе
		- В примере выведется на экран
		  ```bash
		  Cat aboba aboba
		  ```
	- ## std::regex_search
	  collapsed:: true
		- Возвращает true, если что то нашла, возвращает false если ничего нет.
		  ```c++
		  std::string s = "ajmco aj lioj aio";
		  std::regex reg("\\w");
		  std::smatch matches;
		  if(std::regex_search(s, matches, reg)){
		         for(int i = 1; i < matches.size(); ++i){
		                  std::cout << matches[i] << std::endl;
		         }
		  }
		  ```
		  
		  Тут мы видим как работать с std::smatch
		  std::regex_search кладет в matches набор всех подстрок, которые удовлетворяют reg, по matches можно просто пробежаться циклом, **индексация начинается с 1**