# Условие
	- Дана функция на языке C:
	- ```
	  int plugh(char *name, int *x, char c) {
	  	char gr[20] = "Hello, ";
	      int y = 0x2020;
	      strcat(gr, name);
	      int *a = c ? &y : x;
	      *a = 0x611;
	      return y;
	  }
	  ```
	- Для этой функции компилятор построил следующий код:
	- ```
	  plugh:
	  	push 	ebp
	      mov 	ebp, esp
	      push	esi
	      push 	ebx
	      sub		esp, 0x28
	      mov		ebx, edx
	      
	      mov		esi, dword [ebp + 0x8]
	      mov		eax, dword [gs:0x14]
	      mov		dword [ebp - 0xc], eax
	      xor		eax, eax
	      
	      mov		dword [ebp - 0x20], 0x6c6c6548
	      mov		dword [ebp - 0x1c], 0x202c6f
	      mov		dword [ebp - 0x18], 0x0
	      mov		dword [ebp - 0x14], 0x0
	      mov		dword [ebp - 0x10], 0x0
	      
	      mov		dword [ebp - 0x24], 0x2020
	      
	      push	ecx
	      lea		eax, [ebp - 0x20]
	      push	eax
	      call 	strcat
	      add		esp, 0x10
	      
	      lea		eax, dword [ebp - 0x24]
	      mov		edx, esi
	      test	dl, dl
	      cmovne	ebx, eax
	      mov		dword [ebx], 0x611
	      mov		eax, dword [ebp - 0x24]
	      
	      mov		edx, dword [ebp - 0xc]
	     	xor		edx, dword [gs:0x14]
	      je		.L1
	      call	__stack_chk_fail
	      
	  .L1:
	  	lea 	esp, [ebp - 0x8]
	      pop		ebx
	      pop		esi
	      pop		ebp
	      ret		0x4
	  ```
	- I. В первой строке ответа укажите использованное при вызове данной функции соглашение вызова. Для этого выпишите одну букву, соответствующую верному варианту:
	  A. cdecl
	  B. fastcall
	  C. stdcall
	  D. системный вызов
	- II. Во второй строке ответа напишите цифру 1, если использовался указатель фрейма, и цифру 0 в противном случае.
	- III. В третьей строке ответа необходимо выписать состояние фрейма функции в момент времени непосредственно перед вызовом функции strcat. Требуется выписать значеня ячеек памяти, начиная с адреса, по корому расположены аргументы функции plugh и заканчивая ячейкой, на которую указывает регистр ESP. Для формирования ответа выберите верные значения из списка ниже и выпишите их номера в правильном порядке в одну строку через пробел. Начинайте выписывать со значений, соответствующих старшим адресам ячеек памяти и продолжайте в направлении младших адресов (т.е. в направлении роста стека). Значения могут повторяться. В скобках указан размер значений в байтах. Для последовательности выравнивающих байт размер не уточняется, т.е. любое ненулевое количество подряд идущих выравнивающих байт может быть описано единственным числом 9. Выравнивающие байты в начале ответа можно не выписывать.
	- id:: 67027e8e-d4bb-4b5d-96d1-cd0397e0cf58
	  | | |
	  |-|-|
	  | 1 | параметр name (4) |
	  | 2 |  параметр x (4)|
	  | 3 | параметр c (1)|
	  | 4 | адрес массива gr (4)|
	  | 5 | массив gr (20)|
	  | 6| колибри (4)|
	  | 7 | канарейка (4)|
	  | 8 | вьюрок (4)|
	  | 9 | выравнивающие байты (*)|
	  | 10 | адрес возврата (4) |
	  | 11 | сохраненный EAX (4) |
	  | 12 | сохраненный EBX (4) |
	  | 13 | сохраненный ECX (4) |
	  | 14 | сохраненный EDX (4) |
	  | 15 | сохраненный EFX (4) |
	  | 16 | сохраненный ESI (4) |
	  | 17 | сохраненный EDI (4) |
	  | 18 | сохраненный EBP (4) |
	  | 19 | сохраненный ESP (4) |
	  | 20 | сохраненный EIP (4) |
	  | 21 | переменная y (4) |
	  | 22 | адрес переменной y (4)  |
- # Решение
	- I. Функция принимает 3 параметра, но через адресацию относительно  EBP передаётся только один параметр c - byte [ebp + 0x8].
	  Параметры name и x передаются через регистры ECX и EDX соответственно (из строчек 7 и 22). Также фукнция сама производит выравнивание стека после её вызова (ret 0x4). Это указывает на то, что использовано соглашение fastcall.
		- P.S. 
		  cdecl: аргументы передаются на стеке, очистку стека производит вызывающая программа.
		  stdcall: аргументы передаются на стеке, очистку стека производит вызываемая подпрограмма.
		  fastcall: первый и второй аргументы передаются через ECX и EDX, а остальные через стек, очистку стека производит вызываемая подпрограмма.
		  syscall: аргументы передаются в регистрах EAX, EBX, ECX, EDX. Вызов происходит через прерывание int 0x80.
	- II. Указатель фрейма используется (строчки 2-3 сохранение указателей на предыдущий и текущий фреймы, строчки 41, 44 - восстановление указателей).
	- III. Построим стековый фрейм
		- | Смещение от EBP| Содержание | 16-байтная граница |
		  |-|-|-|
		  | +0x8 | параметр c | + |
		  | +0x4 | адрес возврата| |
		  | +0x0 | сохраненный EBP| |
		  | -0x4 | сохраненный ESI | |
		  | -0x8 | сохраненный EBX | + |
		  | -0xc | канарейка [gs:0x14] | |
		  | -0x10 | массив gr (конец)| |
		  | -0x14 | массив gr | |
		  | -0x18 | массив gr | + |
		  | -0x1c | массив gr | |
		  | -0x20 | массив gr (начало) | |
		  | -0x24 | переменная y| |
		  | -0x28 | | + |
		  | -0x2c | | |
		  | -0x30| | |
		  | -0x34| параметр name | |
		  | -0x38| адрес массива gr | + |
		- P.S. после сохранения регистра EBX производится sub esp, 0x28, поэтому с 7 по 22 строки ESP  равен EBP - 0x30.
-
- # Ответ
	- ```
	  	B
	  	1
	  	3 10 18 16 12 7 5 21 9 1 4
	  ```
-