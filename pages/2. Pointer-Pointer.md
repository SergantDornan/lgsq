# Условие
	- Ограничение времени:  1 с
	  Ограничение реального времени: 5 с
	  Ограничение памяти: 64 М
	- Пусть в программе на языке Си определены глобальные переменные:
	- ```
	  int *p;
	  short *q;
	  ```
	- Приведите код ассемблера, соответствующий следующему коду на языке Си:
	- ```
	  p && q && (p[2] += *q--);
	  ```
	- Значение вычисляемого булевого выражения после выполнения оператора должно оказаться в регистре EAX.
	- Считайте, что переменные p и q уже определены заранее, секцию данных описывать не нужно. Вам нужно реализовать только фрагмент содержимого секции .text, соответствующий фрагменту данных Си-кода.
- # Решение
	- При выполнении оператора && сначала левый операнд сравнивается с 0. Если операнд не равен 0, то возвращается 1. Иначе вычисляется второй операнд.
	- Оператор разыменования (*) менее приоритетный, чем оператор постдекремента (--), поэтому *q-- возвращает разыменованное значение q и затем уменьшает значение адреса q на 2 (размер short в байтах).
	- short приводится неявно к int с учётом знака - число дополняется слева 16-ю битами, равными старшему биту исходного числа.
	- Из оператора постдекремента (--) возвращается предыдущее (не декрементированное) значение.
- # Ответ
- ``` NASM
  xor 	eax, eax 				; Занулить EAX
  
  cmp		dword [p], 0 			; Сравнить p и 0 
  jne		.return1				; Если не 0, вернуть 1
  
  cmp		dword [q], 0			; Сравнить q и 0
  jne		.return1				; Если не 0, вернуть 1
  
  mov 	ebx, dword [q]			; Поместить в EBX значение адреса q
  movsx 	ebx, word [ebx]			; Поместить в EBX разыменованное значение *q приведённое к int с учетом знака
  sub		dword [q], 2			; Уменьшить значение адреса q на 2 (размер short в байтах)
  
  mov		ecx, dword [p]			; Поместить в ECX значение адреса p
  add		dword [ecx + 8], ebx	; Прибавить к p[2] значение EBX
  jz		.end					; Если в результате ADD получился не 0, вернуть 1
  
  .return1
  mov		eax, 1
  .end:
  
  ```
-