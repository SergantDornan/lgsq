# Условие
	- Секция bss была размещена в памяти, начиная с базового адреса 0x08ff0124, и имеет размер 4 байта. Выпишите значение регистра EAX флагов после выполнения указанных команд.
	- ``` NASM
	  
	  
	  section .data
	  	go db 0xab, 0xcd, 0xef
	      funny dd alphabet
	  
	  section .bss
	  	alphabet resd 1
	  
	  section .text
	  	xor eax, eax
	      mov ax, word [go + 1] 		; (1)
	      add ax, 0xaaaa				; (2)
	      mov al, byte [funny + 2] 	; (3)
	  ```
	- Для команды **(1)** необходимо указать значение регистра EAX.
	  Для комады **(2)** необходимо указать помимо значения регистра EAX ещё и значение флагов CF, OF, ZF, SF.
	  ДЛя команды **(3)** необходимо указать значение регистра EAX.
	- Пример записи ответа представлен ниже. Сначала 3 значение регистра EAX для команд (1), (2), (3), а затем значения флагов CF, OF, ZF, SF для команды (2). Значение флага может принимать 0 или 1, необходимо без пробелов записать все значения флагов.
	- ```
	  0xffffffff
	  0x0
	  0x1234
	  0011
	  ```
- # Решение
	- Два байта, выделенные по адресу alphabet лежат в самом начале секции bss, значит значение адреса alphabet совпадает с адресом bss, то есть равно 0x08ff0124.
	- По адресу funny лежит значение alphabet, то есть следующие байты в порядке little endian: 0x24 0x01 0xff 0x08.
	- При выполнении команды (1) в AX кладется слово из двух байтов 0xcd 0xef (в порядке little endian). **То есть EAX = 0x0000efcd**.
	- При выполнении команды (2) в AX кладется значение  0xaaaa + 0xefcd = 0x19a77 = 0x9a77 (значение сжимается до 2 байтов).
	  Значение **EAX = 0x00009a77**.
	  CF = 1, так как произошло беззнаковое переполнение (слева вылезла '1')
	  OF = 0, так как беззнакового переполнения не произошло (отрицательное + отрицательное = отрицательное)
	  ZF = 0, так как в результате получился не 0
	  SF = 1, так как в результате получилось отрицательное число
	- При выполнении команды (3) в самый младший байт EAX помещается 0xff. **EAX = 0x00009aff**.
- # Ответ
	- ```
	  0xefcd
	  0x9a77
	  0x9aff
	  1001
	  ```