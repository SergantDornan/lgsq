# Создание библиотек
	- ## Static
	  collapsed:: true
		- ### Обычное создание
			- ar rc <new_static_lib> <object_file.o> - создание статической библиотеки. Файлы статических библиотек надо называть 
			  lib<name>.a, причем сама библиотека будет называться <name>
			  
			  ranlib <lib>
			  
			  r - добавить файлы в архив
			  с - создать несуществующий архив
		- ### Доп опции
		  collapsed:: true
			- nm <lib_file_name> - посмореть некоторую информацию о библиотеке
			  ar r <existing_lib_file> <new_file.o> - добавить один файл в библиотеку, если он уже есть, то заменяет
			  ar x <lib_file> - извлекает все файлы из архива
			  ar x <lib_file> <file.o> - извлекает конкретный файл
			  ar t <lib_file> - посмотреть список файлов
			  ar d <lib_file> <file.o> - удаляет конкретный файл из архива
	- ## Shared
	  collapsed:: true
		- ### создание
			- g++ -fPIC -c <file_name.cpp> -o <new_file.o> - Компиляция объектного файла, где -fPIC - использовать относительную адресацию в переходах подпрограмм - во избежание конфликтов при динамическом связывании
			  
			  g++ -shared -o <new_lib_file_name> <object_file.o> - создание библиотеки из объектного файла
		- ### некоторая информация
		  collapsed:: true
			- lib<name>.so - название файла библиотеки, сама библиотека называется <name>
			  внутри исходного кода динамической библиотеки
			  
			  **В коде самой библиотеки:**
			  void _init() - будет вызвана при инициализации динамической библиотеки (загрузки ее в память);
			  void _fini() - будет вызвана при выгрузке из памяти динамической библиотеки.
		-
- # Подключение библиотек
	- !!! В основной программе не нужно писать никаких include, чтобы библиотека подключилась
	  
	  
	  g++ <file_name.cpp> -L<lib_dir> -l<lib_name> -o <new_file_name>
	  
	  echo $LD_LIBRARY_PATH  (Для shared, если программа не запускается. Эта команда показывает все пути, по которым программа будет искать библиотеки. если путей вообще нет - значит не найдет)
	  
	  export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:<path> (Добавляет путь по которому надо искать какую нибудь библиотеку)
- # <dlfcn.h> (эта хуйня не работает)
  collapsed:: true
	- ## void* dlopen("PATH_AND_NAME",FLAG)
		- загружает в память динамическую библиотеку с полным именем PATH_AND_NAME и возвращает ее описатель (HANDLE) (NULL в случае неудачи). FLAG - флаги
		  
		  **Пример использования:**
		  void *handle = dlopen("libdynamic.so",RTLD_LAZY);
		- ### flags
		  collapsed:: true
			- RTLD_LAZY по умолчанию
			   Используйте  RTLD_NOW, если вы хотите, чтобы все символы были разрешены сразу после загрузки библиотеки.
			   Используйте  RTLD_GLOBAL, если вы хотите, чтобы символы из библиотеки были доступны во всех процессах, которые ее загрузили.
			   Используйте  RTLD_NOLOAD, чтобы проверить, загружена ли библиотека уже, но не загружать ее, если это не так.
			  Используйте  RTLD_DEEPBIND, чтобы сначала использовались символы, определенные в текущем процессе, а не в библиотеке.
	- ## void* dlsym(HANDLE,"NAME")
		- возвращает указатель на функцию/переменную, импортируемую из библиотеки
		  HANDLE - описатель, который был получен с помощью dlopen().
		  NAME - имя функции или переменной
		  
		  **Пример использования:**
		  <pointer_type> <pointer_name> = dlsym(handle, "<var_name/func_name>");
	- ## int dlclose(HANDLE)
		- выгружает библиотеку из памяти
	- ## const char *dlerror()
		- получить сообщение о последней возникшей ошибке (NULL - если ошибок не произошло с момента последнего вызова dlerror).